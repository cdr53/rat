function [Tension,Tdot,Act] = animatlab_CalculateTension(obj,muscle)
    mL = muscle.muscle_length_profile;
    dt = obj.dt_motion;
    Lr = muscle.RestingLength;
    
    m_iVelAvgIndex = 1;
    m_iMuscleVelAvgCount = 4;
    
    % Constants
    PELenPerc = .9;
    MinPeLenPerc = .05;
    SeRestLength = Lr - (Lr*PELenPerc);
    PeMin = Lr*MinPeLenPerc;
    Vm = -.050;
    Iapp = 10;
    tau = .7e-3; %s
    taums = .7;
    dtms = dt*1e3;
    MaxTension = muscle.max_force;
    KseByB = muscle.Kse/muscle.damping;
    KpeByKse = (1 + (muscle.Kpe/muscle.Kse));
    B = muscle.damping;
    Kpe = muscle.Kpe;
    Kse = muscle.Kse;
    
    % Initializations
    Vse(1) = 0;
    Vpe(1) = 0;
    Vmuscle(1:2) = 0;
    Displacement(1) =  mL(1)-Lr;
    Tdot(1) = KseByB*( Kpe* Displacement(1));
    InternalTension(1) =  Tdot(1)*dt;
    Tension(1) = InternalTension(1);
    SeLength(1) = SeRestLength + Tension(1)/Kse;
    PeLength(1) = mL(1)-SeLength(1);
    U(1) = 1e-3*exp((-dtms*taums)/(1-dtms))*Iapp;
    Usim = @(t) Iapp*(1-exp(-t/tau));
    U(1) = Usim(0);
    Vm(1) = U(1)-.06;
    
    for i = 2:length(mL)
        %Store the previous muscle length
         PrevLength = mL(i-1);

        %Calculate the current muscle length.
         Length(i) = mL(i);

        %Calculate the displacement of this muscle d = (x-x*)
         Displacement(i) =  Length(i)-Lr;
         DisplacementRatio(i) =  Length(i)/Lr;

        %Calculate the instantaneous velocity of change of the muscle length.
        if i > 2
           Vmuscle(i) = (mL(i-1)- mL(i-2))/dt;
        end

        %Calculate the active force that is generated by neural stimulation
         TL = Ftl(Length(i),Lr);
         U(i) = 1e-3*((1-dtms/taums)*U(i-1)+(dtms/taums)*Iapp);
         U(i) = Usim(i*dt)*1e-3;
         Vm(i) = (U(i)-.06);
         Act(i) = Fact(Vm(i),muscle);
         A(i) =  TL*Act(i);
         A(i) = 0;

         TLPerc =  TL*100;
         
        %Calculation of the derivitave of the tension
        
         Tdot(i) =  KseByB*( Kpe* Displacement(i) +  B*Vmuscle(i) -  KpeByKse*InternalTension(i-1) +  A(i));  

        %The new tension
            InternalTension(i) =  InternalTension(i-1) +  Tdot(i)*dt;

        %tension can never be negative, but we want to maintain the "internal" calculations so that the
        %time constants are correct. If you shorten the muscle rapidly it will take it some time to 
        %rebuild its tension. This time will be determined by the internal tension, new length,  and the params like viscosity.
        %But the force seen on the muscle itself will still be 0 N because it is slack.
        %If we did not do this then if your muscle is at rest and is pulled, stays steady, and then relaxed, then
        %it would end up generating a negative tension. (See fig 4 of shadmehr web doc on muscle model).
        %There is a problem in this figure in that you can see that the muscle produced negative tension and this is not 
        %possible in a real muscle.
        if( InternalTension(i) >= 0)
            Tension(i) =  InternalTension(i);
        else
            Tension(i) = 0;
        end

        %Make certain that the tension never exceed the absolute maximum set by the user.
         
        if( Tension(i) >  MaxTension)
            Tension(i) =  MaxTension;
        end

        SeLPrev =  SeLength(i-1);
        PeLPrev = Lr - SeLPrev;

        SeLength(i) =  SeRestLength + (Tension(i)/Kse);
        SeDisplacement(i) =  SeLength(i) -  SeRestLength;
        if( SeDisplacement < 0) 
            SeDisplacement = 0;
        end

        PeLength(i) =  Length(i) -  SeLength(i);
        if( PeLength(i) < PeMin)
            SeLength(i) =  Length(i)  - PeMin;
            PeLength(i) = PeMin;
        end

         Vse(i) = ( SeLength(i)- SeLPrev)/dt;
         Vpe(i) = ( PeLength(i)- PeLPrev)/dt;
    end

    T_out = [];
    T_find = [];
    T = [];
    [T_find,T_out,T] = compute_muscle_passive_tension(obj,muscle,0);

	 %IbRate =  IbDischargeConstant* Tension;

%     if ~m_bEnabled
%         Tension = 0;
%         InternalTension = 0;
%     end

    function fltTl = Ftl(fltL, RestingLength)
        fltTl = CalculateLTGain(fltL, RestingLength);
        if fltTl<0
            fltTl = 0;
        end
    end

    function fltTl = CalculateLTGain(fltInput, RestingLength)
        fltLceNorm = fltInput -  RestingLength;
         TLc = .5* RestingLength;
        fltTl = (-((fltLceNorm^2)/ TLc)  + 1);
        if fltTl<0 
            fltTl = 0;
        end
    end

    function fltAct = Fact(fltStim,muscle)
        fltAct = CalculateSTGain(fltStim,muscle);
        if fltAct < 0
            fltAct = 0;
        end
    end

    function outVal = CalculateSTGain(fltInput,muscle)
         Bb = muscle.ST_max;
         Aa = muscle.x_off;
         C = muscle.steepness;
         D = muscle.y_off;
        if(InLimits(fltInput,'ST',muscle))
            outVal = (( Bb/(1+exp( C*( Aa-fltInput)))) +  D);
        else
            outVal = CalculateLimitOutput(fltInput,'ST',muscle);
        end
    end

    function outVal = InLimits(fltInput,curveType,muscle)
        m_bUseLimits = 1;
        switch curveType
            case 'LT'
                 LowerLimit = min(muscle.muscle_length_profile);
                 UpperLimit = max(muscle.muscle_length_profile);
            case 'ST'
                 LowerLimit = -.06;
                 UpperLimit = -.04;
        end
        if( m_bUseLimits && ( (fltInput <  LowerLimit) || (fltInput >  UpperLimit) ) ) 
            outVal = false;
        else
            outVal = true;
        end
    end

    function outVal = CalculateLimitOutput(fltInput,curveType,muscle)
        switch curveType
            case 'LT'
                 LowerLimit = min(muscle.muscle_length_profile);
                 UpperLimit = max(muscle.muscle_length_profile);
            case 'ST'
                 LowerLimit = -60;
                 UpperLimit = -40;
        end
        if(fltInput <  LowerLimit)
            outVal =  LowerOutput;
        elseif (fltInput >  UpperLimit)
            outVal =  UpperOutput;
        else
            outVal = 0;
        end
    end
end